================================================
== Gaussian
================================================
Gaussian variable = average of some number of white noise variables.
the more uniform noise samples are averaged, the tighter the standard deviation of Gaussian white noise becomes.


================================================
== 3D terrain generation
================================================
make a 3D generator that builds the world just like the 2D terrain generator did in GridVenture.
instead of using lines, use planes.

the generator will build one big plane. then it will break it up into smaller planes. then into smaller planes.

	•	have with one empty two-dimensional array of floating point (elevation) values.
	
	•	generate a plane to fit in this space.
		specify the height at the center of the plane.
		specify the slope of the plane.
		
	•	break this plane up into four smaller planes
	
	•	generate center heights for each of these smaller planes.
		The center height will be calculated by the slope of the parent plane.
		However, the height will be subject to Gaussian noise.
		Then the slope of this smaller plane will be generated by the two known points
		(the center of the bigger plane and the center of the smaller plane).
	
	• 	wash, rinse, repeat.

the planes will be centered in the middles of blocks.
consequently, it will help a lot if the length and with of blocks are the same and powers of 3.

everything needs to be symmetrical down to the finest precision (a single floating point element in the 2D array of elevation values in any given block).
therefore, blocks will be one of the following:

3x3,
9x9,
27x27,
81x81,
243x243,
729x729,
2187x2187,
etc...

243x243 looks the most promising because 243 elements_wide * 243 elements_tall * 4 bytes = 236196 bytes  =~ (230 kB)
The maximum amount of consecutive data in an array is 2 MB, I think.
So this value should be within the acceptable range.
so each block will be 230 kB with a 243x243 2D array of elevation values.


================================================
== rain filter
================================================
add a rain filter to the game. It will simulate rain and erosion on a landscape.
there would be simulated rain particles that would shower a landscape.
each rain particle would fall down the steepest slope.
as it falls down slopes, it would take away some of the land that it was just on and place it on the land that it is flowing to (eroding the land, bringing more land downhill).
this could produce some very interesting patterns.


================================================
== make all graphics in code
================================================
use no pre-made textures.
generate all game textures in code procedurally.
generate bugs and animals and trees and things in code with simple shapes.
they would probably needed to be generated procedurally (like a fractal).
so the creatures that exist in the fractal map are, themselves, fractals.

maybe make the creatures are 3D? 3d models?
3D creature fractals?
YES. That would be really complicated but probably pretty cool.
The nice thing about the 2D images is that you wouldn't need to constantly render a 3D object.
Rendering the 2D


================================================
== bookmark locations on the map
================================================
Allow the user to bookmark locations on the map.
The bookmark would be a camera view relative to some block.


================================================
== create randomly generated elements
================================================
each game world would have a different set of elements that are available in that world.
each element would have a randomly generate english-ish name.
give each element various parameters:
	- melting point
	- boiling point
	- atomic mass
	- solubility in liquids? which liquids? all? or just some types? which types?
	- color
	- distribution over levels
	- ore deposits? or will there be standing liquids?
	- scarcity (somewhat continuous over several levels)
	- Depending on the temperature of the level, this material will either be found...
		a. in the atmosphere (evaporated)
		b. in standing bodies of water
		c. in flowing bodies of water
		d. in solid ore deposits.


================================================
== make animals
================================================
animals will be able to run genetic algorithms to find the best ways to do things.
Each animal might have several different types of algorithms that it can do:
such as path finding, mating, interacting with others in its own species, and interacting with animals outside its own species.

I imagine the animals to be the main fascination in this game.
The user will be able to interact with the environment around the animals.
The user might also be able to set "global commands" for the colony of animals.
But the user will not control each unit individually.
The units should be fully autonomous.
They should be able to learn how to do things.
Also, maybe they will try to do things on their own.
Like find food?


================================================
== HEIGHT vs WIDTH
================================================
because the blocks are going to be symmetrical (for ease of programming), the height and width will be the same.
So why have height and width?
It would make more sense to have, BLOCK_SIZE, BLOCK_SIZE_1_3.
There would be less definitions and it would make the code more elegant.
Implement this sometime.


================================================
== RENDER EACH BLOCK INDEPENDENTLY
================================================
Render each block independently to a surface, then convert to a texture (in graphics)
Then rendering the world would be a simple task of sticking the pre-rendered blocks where they need to go.
Because the textures exist in graphics memory, the graphics card would handle the scaling of all the textures.
This would reduce the strain on the CPU.
Only when there is an change to the elevation of a block does that block need to be re-rendered.

This same technique could be applied to animals/creatures.
They could all be rendered in some base resolution, then when the time comes to print them to the screen, the textures could be applied by the graphics card.
This would be much faster than the alternative of making the CPU render each animal every single frame (which would be really taxing on the processor)

>>>>>>>>>> UPDATE <<<<<<<<<<<<<<<

this has now been implemented, however, there is one crucial thing that needs to be considered:
How many textures do I want to have floating around?
maybe once the game reaches a certain number of textures floating around, it will just delete all of them (or maybe half of them).
it should delete the oldest half of the textures (not all of them).





